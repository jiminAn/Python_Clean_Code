##  chapter 01. 소개, 코드 포매팅과 도구

 ### 01. 클린 코드의 의미

프로그래밍 언어의 진정한 의미는 아이디어를 다른 개발자에게 전달하는 것

클린 코드의 본질은 다른 엔지니어가 코드를 읽고 유지 관리할 수 있는지 여부

### 02. 클린 코드의 중요성

1.  민첩한 개발과 지속적인 배포
2. 기술 부채*의 감소
3. 유지보수성의 향상
4. 애자일 개발을 통한 효과적인 작업 진행
5. 성공적인 프로젝트 관리

*기술부채 : 나쁜 결정이나 적당한 타협으로 생긴 소프트웨어적 결함
#### 2.1 클린 코드에서 코드 포매팅의 역할
클린코드는 품질 좋은 소프트웨어 개발, 견고하고 유지보수가 쉬운 시스템 제작, 기술 부채를 회피하는 것

따라서, `PEP-8` 표준 (또는 다른 표준)을 100% 준수한다 하여도 클린코드가 아닐 수 있음.


#### 2.2 프로젝트 코딩 스타일 가이드 준수
좋은 코드 레이아웃에서 가장 필요한 특성은 일관성. 코드가 일관되게 구조화되어 있으면 가독성이 높아지고 이해하기 쉬워짐.

**이해하기 쉽고 읽기 쉬운 코드**와  **구조화된 패턴**을 가진 코드를 작성해야 하기 때문에 파이썬이 따라야 하는 코딩 스타일은 `PEP-8`이다.

###### PEP(Python Enhancement Proposal의 약자로 파이썬 개선을 위한 제안서를 의미. 각 제안서는 고유한 번호를 갖게 되는데 PEP 8번 Style Guide for Python Code에서 코딩 컨벤션에 대한 내용을 다룬다)

`PEP – 8` 의 특징
		
1. 검색 효율성 ( 특정 파일이나 파일의 일부에서 특정 문자열을 찾는 기능 )
2. 일관성 
3.  코드 품질

### 03. Docstring과 어노테이션 

파이썬 코드 안에 직접 문서화를 하는 방법

코드를 문서화하는 것은 주석을 추가하는 것과 다른 것. 문서화를 통해 데이터 타입이 무엇인지 설명하고 예제를 제공할 수 있음.

#### 3.1 Docstring

소스 코드에 포함된 문서이다. 즉 , 코드에 대한 문서화를 코드 내부에 실시하는 것.

문서화를 통해서 코드에 대해 명확하고 편리하게 설명할 수 있으므로 사전에 버그를 방지할 수 있음.

예상되는 함수의 입력과 출력을 문서화하면 사용자가 사용할 때 함수가 어떻게 동작하는 지 이해하기 쉬움.

`docstring`은 코드에서 분리되거나 독립된 것이 아님. 객체에 `docstring`이 정의되어 있다면,  `__doc__`속성을 통해 `docstring`에 접근이 가능
```python
>>> def my_function():
	""" 임의의 계산 수행 """
	return None
>>> my_function.__doc__
'임의의 계산 수행'
```
#### 3.2  Annotation
파이썬에서 사용하는 `어노테이션`의 기본 아이디어는, 코드를 사용하는 이에게 함수나 클래스에 대해 그 **인자값의 형태 또는 반환값**을 알려주자는 **힌트** 라고 할 수 있다.

`어노테이션`을 사용해 변수의 예상 타입을 지정할 수 있음.
```python
class Point:
	def __init__(self, lat, long):
		self.lat = lat
		self.long = long
	
	def locate(latitude: float, longitude: float) -> Point:
	""" 맵에서 좌표에 해당하는 객체를 검색 """
```
`latitude`와 `longitude`는 `float`타입의 변수임. 

이를 통해 함수 사용자는 예상되는 타입을 알 수 있음. 또한, 함수 반환 값에 대한 예상 타입을 지정할 수 있음.

`어노테이션`을 적용하면 , 그 개체에 대해 `__annotations__`라는 속성이 생긴다. 이 속성은 `어노테이션`의 이름과 값을 매핑한 사전의 값이다.
```python
>>> locate.__annotations__
{'latitude':float, 'longitude': float, 'return':__main__.Point}
```
코드의 시맨틱이 보다 의미 있는 개념을 갖게 되면 코드를 이해하기 쉽고 특정 시점에 어떻게 될지 예측할 수 있다.

#### 3.3 Annotation 은 docstring을 대체하는 것일까?
`Docstring`과 `Annotation`은 서로 보완적인 개념이다. 

따라서, `Annotation`으로 타입힌팅을 해도 `docstring`을 통한 더 나은 문서화를 위한 여지를 남겨두어야 함.
```python
def data_from_response(response: dict) -> dict:
	if response["status"] != 200:
		raise ValueError
	return {"data": response["payload"]
```
`docstring`을 사용한 보다 나은 설명
```python
def data_from_response(response: dict) -> dict:
	""" response에 문제가 없다면 response의 payload를 반환

	- response 사전의 예제::
	{
		"status": 200, #<int>
		"timestamp": "....", # 현재 시간의 ISO 포맷 문자열
		"payload": {...} # 반환하려는 사전 데이터
	}

	- 반환 사전 값의 예제::
	{"data": {..}}

	- 발생 가능한 예외:
	- HTTP status가 200인 아닌 경우 ValueError 발생
	"""
	if response["status"] != 200:
		raise ValueError
	return {"data": response["payload"]

```
#### 3.4 기본 품질 향상을 위한 도구 설정

모든 검사를 자동화하고 테스트 또는 체크리스트의 일부가 되어 지속적인 통합 빌드의 하나가 되어야 함. 검사에 실패하면 빌드도 실패해야 함.  

위의 동작이 코드 구조의 연속성(일관성)을 확보할 수 있는 유일한 방법.

#### 3.4.1 Mypy를 사용한 타입 힌팅

파이썬의 정적 타입 검사 도구. 프로젝트의 모든 파일을 분석하여 타입 불일치를 검사

잘못 탐지하는 경우도 발생. 주석을 추가하여 무시.

```python
type_to_ignore = "something" # type: ignore
```
#### 3.4.2 Pylint

코드의 구조를 검사하는 도구. 기본적으로 `PEP-8`을 준수했는지 여부를 검사한다

#### 3.4.3 자동 검사 설정

리눅스 개발환경에서 빌드를 자동화하는 가장 일반적인 방법 `makefile`을 사용하는 것

`makefile`은 프로젝트를 컴파일하고 실행하기 위한 설정을 도와주는 도구이고 포매팅 검사나 코딩 컨벤션 검사를 자동화하기 위해 사용할 수도 있다.

  1. 코딩 가이드라인 검사
  2. 올바른 타입을 사용했는지 검사
  3. 최종적으로 테스트 실행
  
  위 단계 중 하나라도 실패 시 전체 프로세스가 실패한 것으로 간주
  
Black : PEP – 8을 준수했는지 여부를 검사하고 자동으로 바꿈

### 04. 요약

클린코드는 기술부채를 최소화하고 가독성과 유지보수성 그리고 타인의 이해도를 높이는 효과적인 코드의 작성법에 관한 것
