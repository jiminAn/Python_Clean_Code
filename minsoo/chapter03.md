## Chapter 03. 좋은 코드의 일반적인 특징

### 01. 계약에 의한 디자인
---
##### 소프트웨어는 사용자가 직접 호출하기도 하지만 코드의 다른 부분에서 호출하는 경우도 있다

###### Ex) 애플리케이션의 책임을 나누어 레이어나 컴포넌트로 분리한 경우
#####  컴포넌트는 기능을 숨겨 캡슐화  & 고객에게는 API를 노출
######  컴포넌트 : 소프트웨어 시스템에서 독립적인 업무 또는 독립적인 기능을 수행하는 모듈
#####  API를 디자인할 때 예상되는 입력, 출력 및 부작용을 문서화

#####  그러나,  문서화가 런타임 시의 소프트웨어의 동작을 강제 X
#####  따라서 제대로 작동하길 기대하는 것과 호출자가 반환 받기를 기대하는 것은 <u>디자인의 하나</u>가 되어야 함

### 02. 계약에 의한 디자인
---
##### " 관계자가 기대하는 바를 암묵적으로 코드에 삽입하는 대신 양측이 동의하는 계약을 먼저 한 다음, 계약을 어겼을 경우는 명시적으로 왜 계속할 수 없는 지 예외를 발생시키라는 것"

#### 2.1 사전 조건 (precondition)

 - ##### 함수나 메서드가 제대로 동작하기 위해 보장해야 하는 모든 것
  - ##### 호출자에게 부과된 임무
 
 - #####  파라미터에 제공된 데이터의 유효성 검사
 - ##### 데이터베이스, 파일, 이전에 호출된 다른 메서드의 검사 등 까지 유효성 검사를 하는 것이 좋음.


#### [유효성 검사] 

#### 1) 관용적인 접근법
##### : 클라이언트가 함수를 호출하기 전에 모든 유효성 검사를 하게 하는 것
#### 2) 까다로운 접근법
##### : 함수가 자체적으로 로직을 실행하기 전에 검사하도록 하는 것

##### 어떤 방식으로 유효성 검사를 하든 '중복 제거 원칙'을 적용해야 함
##### 즉, 검증 로직을 클라이언트에 두거나 함수 자체에 두어야 함

#### 2.2 사후조건 (postcondition)

- ##### 메서드 또는 함수가 반환된 후의 상태를 강제하는 계약의 일부

- ##### 호출자가 컴포넌트에서 기대한 것을 제대로 받았는지 확인하기 위해서 수행

#### 2.3 불변식 (invariant)
- ##### 함수의 로직에 문제가 없는지 확인하기 위한 것
- ##### docstring에 불변식에 대해 문서화하는 것이 좋음

#### 2.4 부작용(side-effect)
- ##### 선택적으로 코드의 부작용을 docstring에 언급

#### [계약에 의해 디자인을 하는 이유]

##### 1) 오류 발생 시, 쉽게 찾아낼 수 있음.

##### 2) 잘못된 가정 하에 코드의 핵심 부분이 실행되는 것을 방지

###### →  책임의 한계를 명확히 하는데 도움이 됨

##### 사전조건 검증 실패 →  클라이언트 결함

##### 사후조건 검증 실패 →  특정 모듈 or 제공 클래스 자체 결함



#### 2.5 파이썬스러운 계약

##### PEP – 316  (Programming by Contract for Python) 를 적용하는 가장 좋은 방법은 다음과 같다

##### 1) 메서드, 함수 및 클래스에 RuntimeError 예외 또는 ValueError 예외를 발생시키는 제어 메커니즘을 추가하는 것

##### 2) 문제를 정확하게 특정하기 어려울 땐 '사용자 정의 예외'를 만드는 것
##### 3) 코드를 가능한 격리된 상태로 유지하는 것

#### 2.6 계약에 의한 디자인 – 결론

##### 1) 문제가 있는 부분을 효과적으로 식별할 수 있다.

- #####  오류가 발생했을 때 코드의 어떤 부분이 손상되었는지 계약이 파손되었는지가 명확해짐

##### 2) 프로그램 구조를 명확히 하는 목적

- #####  함수나 메서드가 정상 동작하기 위해 기대하는 것이 무엇인지, 무엇을 기대할 수 있는지 정의

- ##### 위의 방법이 효과적이기 위해서는 함수에 전달되는 객체의 속성과 반환 값을 검사하고 이들이 유지해야하는 조건을 확인하는 등의 작업을 해야함

### 03. 방어적(defensive) 프로그래밍
---
- #####  DbC와는 다른 접근 방식을 따름

- #####  게약에서 예외를 발생시키고 실패하게 되는 모든 조건을 기술하는 대신 객체, 함수 또는 메서드와 같은 코드의 모든 부분을 유효하지 않은 것으로부터 <u>스스로 보호할 수</u> 있게 하는 것

- ##### DbC와 다른 철학을 가졌다는 의미가 아닌, 다른 디자인 원칙과 서로 보완 관계에 있을 수 있다는 것을 의미

#### 3.1 에러 핸들링 

- ##### 오류가 발생하기 쉬운 상황에서 사용함

######  Ex) 데이터 입력 확인

- ##### 주요 목적 : 에러에 대해서 실행을 계속할 수 있을지 아니면 극복할 수 없는 오류여서 프로그램을 중단할지를 결정하는 것

- ##### 에러 처리 방법: 값 대체

#### 3.1.1 값 대체 

- ##### 오류가 발생해서 소프트웨어가 잘못된 값을 생성하거나 전체가 종료될 위험이 있을 경우 결과 값을 안전한 다른 값으로 대체하는 것

###### 안전한 다른 값 : 정합성을 깨지 않는 다른 값 
###### ex) 기본 값 or 잘 알려진 상수, 초기 값

- #####  항상 값 대체가 가능한 것은 아님

- ##### 값 대체는 견고성과 정확성 간의 트레이드오프로써 결정을 내릴 수 있다.

- ##### 기본 값으로 동작 가능한 것들 (사전, 환경 변수, 사용자 정의 함수)

- ##### 일반적으로 누락된 파라미터를 기본 값으로 바꾸어도 큰 문제가 없지만 "오류가 있는 데이터를 유사한 값으로 대체하는 것은 더 위험하며 일부 오류를 숨겨버릴 수 있다"

#### 3.1.2 예외 처리 

##### 함수는 심각한 오류에 대해 명확하고 분명하게 알려줘서 적절하게 해결할 수 있도록 해야 한다. → 예외 메커니즘

#### 3.2 파이썬에서 어설션 사용하기
##### 어설션은 절대로 일어나지 않아야 하는 상황에 사용 됨
###### → assert 문에 사용된 표현식은 불가능한 조건을 의미 
##### 어설션에 실패하면 반드시 프로그램을 종료시켜야 함
### 04. 관심사의 분리 
---
##### 책임이 다르면 컴포넌트 ,계층 또는 모듈로 분리되어야 한다.

##### '관심사 분리'의 목표 : <u>파급 효과</u>를 최소화하여 유지보수성을 향상시키는 것

##### 애플리케이션의 나머지 부분에 대한 영향성을 최소화하면서 코드를 수정하거나 리팩토링을 하고 싶다면 적절한 캡슐화가 필요

##### -- DbC 원칙과 유사하지만 관심사의 분리는 좀 더 큰 내용이다.

####  4.1 응집력(cohension)과 결합력(coupling) 

##### 응집력 : 객체가 작고 잘 정의된 목적을 가져야 하며 가능하면 작아야 한다는 것을 의미한다

###### 응집력이 높을수록 더 유용하고 재사용성이 높아진다

##### 결합력 : 두 개 이상의 객체가 서로 어떻게 의존하는지 나타내는 것

###### 객체 또는 메서드의 두 부분이 서로 의존적일 경우 낮은 재사용성, 파급 효과, 낮은 수준의 추상화와 같은 바람직하지 않은 결과를 가져온다.

### 05. 개발 지침 약어
---

#### DRY (Do not  Repeat Yourself)

#### OAOO (Once And Only Once)

##### 코드에 있는 지식은 단 한번, 단 한 곳에 정의되어야 한다 즉 코드 중복을 피해야 한다

- ##### 오류가 발생하기 쉽다

- ##### 비용이 비싸다

- ##### 신뢰성이 떨어진다

##### 코드 중복은 기존 코드의 지식을 무시함으로써 발생한다 따라서 코드의 특정 부분에 의미를 부여함으로써 해당 지식을 식별할 수 있다.

##### 코드 중복을 제거하는 방법

- ##### 함수 생성 기법, 새로운 객체 만들기, 컨텍스트 관리자, 데코레이터 등
#### YAGIN (You Ain’t Gonna Need it)

##### 과잉 엔지니어링을 하지 않기 위해 솔루션 작성 시 계속 염두에 두어야 하는 원칙이다.

##### 디자인을 할 때 내린 결정으로 특별한 제약 없이 개발을 계속 할 수 있다면, 굳이 필요 없는 추가 개발을 하지 말라는 것.

#### KIS (Keep It Simple)

##### 문제를 올바르게 해결하는 최소한의 기능을 구현하고 필요한 것 이상으로 솔루션을 복잡하게 만들지 않도록 해야 한다.

##### 파이썬의 철학을 기억하자 : 단순한 것이 복잡한 것보다 낫다.

#### EAFP(Easier to Ask Forgiveness than Permission)

##### - 일단 코드를 실행하고 실제 동작하지 않을 경우 대응한다는 뜻이다.

#### LBYL(Look Before You Leap)

##### - 실행하기전에 실행할 수 있는 지 확인하라는 것

##### 파이썬은 EAFP 방식으로 만들어졌으며, EAFP 방식을 사용해야함.
#### (암묵적인 것보다 명시적인 것이 더 좋다)
