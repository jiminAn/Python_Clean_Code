> 해당 글은 <파이썬 클린 코드 : 유지보수가 쉬운 파이썬 코드를 만드는 비결, 마리아노 아나야 지음> 책의 8장을 참고하여 작성되었습니다

# Chapter 08. 단위 테스트와 리펙토링

단위 테스트는 SW 유지보수에 있어서 결정적인 역할을 하므로 모든 품질 프로젝트에 빠질 수 없는 부분이다. 따라서 해당 장에서는 핵심 개발 전략으로서의 자동화 테스트, 안전한 코드 수정, 점진적 기능 향상에 대한 것들에 대해 알아보도록 하자

### 8장의 목표

- Agile SW 개발 방법론에서 자동화된 테스트가 중요한 이유
- 단위 테스트가 코드 품질에 대한 거울이 되는 이유
- 자동화된 테스트와 품질 게이트를 설정하기 위한 프레임워크와 도구
- 단위 테스트가 문서화와 도메인 문제의 깊은 이해에 도움을 주는 이유
- 테스트 주도 개발(TDD - test driven development)의 개념



## 디자인 원칙과 단위 테스트

------

**단위 테스트란?** 다른 코드의 일부분이 유효한지를 검사하는 코드로, 비즈니스 로직이 특정 조건을 보장하는지를 확인하기 위해 여러 시나리오를 검증하는 코드이다

- 일반적으로 애플리케이션의 "핵심"을 검증하는 것이라 생각함 -> 단위 테스트를 보조 수단으로 생각
- 단위 테스트는 SW의 핵심이 되는 필수적인 기능으로 일반 비즈니스 로직과 동일한 수준으로 다루어야 함

**단위 테스트의 특징**

1. 격리

   - 다른 외부 에이전트와 완전히 독립적이어야 하며 비즈니스 로직에만 집중해야 한다
     - DB에 연결하지 않아야 하고, HTTP 요청도 하지 않아야 함
   - 테스트 자체가 독립적이라는 것을 의미
     - 이전 상태와 관계없이 테스트는 임의의 순서로 실행될 수 있어야 함

2. 성능

   - 신속하게 실행되어야 함
   - 반복적으로 여러번 실행될 수 있도록 설계해야 함

3. 자체 검증

   - 실행만으로 결과를 결정할 수 있어야 함

     - 즉, 단위 테스트를 처리하기 위한 추가 단계가 없어야 함

     

### 자동화된 테스트의 다른 형태

**단위 테스트 vs 테스트 스위트**

- 단위 테스트 : 함수 또는 메서드와 같은 매우 작은 단위를 확인하기 위함
  - 최대한 자세하게 코드를 검사하는 것이 목적
- 테스트 스위트(test suite) : 단위 테스트의 집합으로 클래스를 테스트하는데 사용
  - 테스트 스위트를 구성하는 테스트들은 메서드처럼 보다 작은 것을 테스트함

**그 외에 다양한 테스트 방법들**

이 두 가지 테스트를 하게 될 경우 실행하는데 더 많은 시간이 걸리기 때문에, 단위 테스트의 중요한 특성인 속도를 읽게 되는 단점이 있다

- 인수 테스트(acceptance test) : 유스케이스(use case)를 활용하여 사용자의 관점에서 시스템의 유효성을 검사하는 자동화된 테스트
- 통합 테스트(integration test) : 한 번에 여러 컴포넌트를 테스트하여 종합적으로 예상과 같게 잘 동작하는지 검증함
  - 부작용이나 격려를 고려하지 않음
  - 즉, HTTP 요쳥을 하거나 DB에 연결하는 등의 작업을 수행하는 것이 가능/바람직함

**좋은 테스트 방법이란**

좋은 개발 환경을 구축했다면 개발자는 전체 테스트 스위트를 만들고 코드에 수정이 생길 때마다 반복적으로 단위 테스트와 리펙토링을 할 수 있어야 함

- 예시 
  - 코드를 수정하고 PULL REQUEST가 생기면 CI(Continuous Integration) 서비스가 실행되어 해당 브랜치에 빌드를 실행한다
  - 통합 테스트나 인수 테스트가 있는 경우는 빌드 중에 단위 테스트도 함께 수행한다
    - 일반적으로 단위 테스트는 항상 수행되길 원하고, 통합 테스트나 인수 테스트는 그보다 덜 자주 수행되길 바람
    - 이유는, 전략적으로 단위 테스트에서 작은 기능을 많이 테스트하고, 단위 테스트에서 확인할 수 없는 부분을 다른 자동화된 테스트에서 커버하려고 하기 위함

### 단위 테스트와 agile SW 개발

최근의 SW 개발은 가능한 신속하고 지속적으로 가치를 제공하고자 함

- 더 빠른 피드백을 받을 수록 더 쉽게 코드를 수정할 수 있다는 생각
- 1997년 리눅스 회의에서 처음 공개한, 성당과 시장(The Cathedral and the Bazaar)에서 추구하는 사상과 같음

변화에 효과적으로 대응할 수 있는 SW 개발을 하고자 한다면, 유연하고 확장 가능해야 하다

- 디자인과 상관없이 코드만으로 변경에 충분히 유연하다는 보장은 할 수 없다

- 이는 단위 테스트가 보장할 수 있음

  - 프로그램이 명세에 따라 정확하게 동작한다는 공식적인 증거가 될 수 있음

  - 즉, 단위 테스트(혹은 자동화된 테스트)는 기대한 것처럼 코드가 동작한다는 확신을 줄 수 있는 안정망 역할을 함

    

### 단위 테스트와 SW 디자인

좋은 SW란 테스트 가능한 SW이며, 테스트의 용이성은 클린 코드의 핵심 가치이다

- 테스트 용이성 : SW를 얼마나 쉽게 테스트 할 수 있는지를 결정하는 품질 속성

단위 테스트는 실제 코드의 작성 방식에 직접적인 영향을 미치며 아래와 같은 단계를 가진다

1. 발견 단계 : 특정 코드에 단위 테스트를 해야겠다고 발견하는 단계
2. 작성 단계 : 더 나은 코드를 작성하는 단계
3. TDD 단계 : test-driven design 단계로, 궁극적으로 모든 코드가 테스트에 의해 작성되는 단계

테스트가 어떻게 코드의 개선으로 이어질 수 있는지 예제를 통해 살펴보도록 하자

```python
# 특정 작업에서 얻은 지표를 외부 시스템에 보내는 프로세스
class MetricsClient:
	"""타사 지표 전송 클라이언트"""
	def send(self, metric_name, metric_value):
		if not isinstance(metric_name, str):
			raise TypeError("metric_name으로 문자열 타입을 사용해야 함")
      
		if not isinstance(metric_value, str):
			raise TypeError("metric_value로 문자열 타입을 사용해야 함")

		logger.info("%s 전송 값 = %s", metric_name, metric_value)

class Process:
	def __init__(self):
		self.client = MetricsClient() # 타사 지표 전송 클라이언트

	def process_iterations(self, n_iterations):
		for i in range(n_iterations):
      result = self.run_process()
      self.client.sent("iteration.".format(i), result)
```

- 타사에서 제공하는 라이브러리는 직접 제어할 수 없으므로 실행 전에 정확한 타입을 제공해야 함

  - 즉, 단위 테스트를 통해 이러한 문제가 발생하지 않는다는 것을 확실히 해야함

- Process 객체의 클라이언트를 모의하여 테스트 진행

  ```python
  class WrappedClient:
  	def __init__(self):
  		self.client = MetricsClient()
  	
  	def send(self, metric_name, metirc_value):
  		return self.client.send(str(metric_name), str(metric_value))
  
  class Process:
  	def __init__(self):
  		self.client = WrappedClient() # 자체 클래스를 지표 전송 클라이언트로 사용
  		... # 나머지 코드는 그대로 유지
  ```

  - 이러한 컴포지션 방식은 어댑터 디자인 패턴과 유사(ch9 장에서 자세히 다룸)
  - 이 경우 새로운 객체이므로 새로운 단위 테스트를 가질 수 있음
  - 메인 코드에 대해 직접 단위 테스트를 작성하면 추상화를 하지 못함

- 메서드를 분리했으므로, 실제 단위 테스트를 작성해보자 

  ```python
  import unittest
  from unittest.mock import Mock
  
  class TestWrappedClient(unittest.TestCase):
  	def test_send_converts_types(self):
  		wrapped_client =  WrappedClient()
  		wrapped_client.client = Mock()
  		wrapped_client.send("value", 1)
  		wrapped_client.client.send.assert_called_with("value", "1")
  ```

  - Mock은 어떤 종류의 타입에도 사용할 수 있는 객체로, 단위 테스트 시 사용 편리
  - 1, "1" 을 넘겨주는 것 주의

### 테스트 경계 정하기

테스트의 범위는 우리가 작성한 코드의 범위로 한정할 것

- 외부 라이브러리, 모듈과 같은 의존성까지는 확인하지 말자
- 의존성을 테스트 하는 것은 우리의 책임이 아니므로 외부 프로젝트에 대해서는 자체적인 테스트가 있다고 가정하도록 하자
- 외부 의존성의 경우 올바른 파라미터를 사용해 호출하면 정상적으로 실행된다는 것만 확인해도 충분

좋은 단위 테스트는 시스템의 경계에는 패치를 적용하여 넘어가고 핵심 기능에 초점을 두는 것

- 외부 라이브러리를 테스트하지는 않지만, 제대로 호출되었는지는 확인



## 테스트를 위한 프레임워크와 도구

------

### 단위 테스트 프레임워크와 라이브러리

